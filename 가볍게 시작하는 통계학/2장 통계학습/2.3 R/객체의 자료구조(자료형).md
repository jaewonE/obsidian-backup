- [[#1. 스칼라(Scalar)|1. 스칼라(Scalar)]]
- [[#2. 벡터(Vector)|2. 벡터(Vector)]]
- [[#3. 요인(Factor)|3. 요인(Factor)]]
- [[#4. 행렬(Matrix)|4. 행렬(Matrix)]]
- [[#5. 배열(Array)|5. 배열(Array)]]
- [[#6. 데이터프레임(DataFrame)|6. 데이터프레임(DataFrame)]]
- [[#7. 리스트(List)|7. 리스트(List)]]


## 1. 스칼라(Scalar)

단순값이다. 실수, 문자열, 논리값의 3가지 자료형을 가진다.

문자열은 파이썬과 같이 따옴표와 쌍따옴표를 구분하지 않으며 시작문자와 맺음문자가 같으면 된다. 하지만 쌍따옴표를 사용하는 것이 권장된다.

논리값인 참과 거짓은 모두 대문자로 입력해야 한다. (`TRUE` , `FALSE`) 간단하게 `T` , `F` 를 통해 사용할 수도 있다.

```r
> x <- "Hello"
> y <- 5.2
> z <- TRUE
```

## 2. 벡터(Vector)

벡터는 **같은 자료형**을 가진 스칼라 값들을 순서를 가지고 일렬로 나열한 자료구조이다. 

타언어의 배열과 유사한다. 다만 R에서는 3차원 이상의 행렬에 대하여 ************배열************이라는 명칭을 사용하니 **********************************************************************************************벡터**********************************************************************************************라는 정확한 명칭으로 사용하자.

벡터는 함수 `c` 를 통해 생성하는 것이 일반적이나, 실수 값을 가진 벡터의 경우 `시작값:종료값`
의 형태로도 생성할 수 있다.(이 경우 벡터는 시작값에서부터 종료값에 이르기 전까지 1씩 증가한 실수들로 채워진다.)

`length(x)` 와 같이 벡터의 길이를 확인할 수 있다.

```r
> x <- c("a", "b", "c", "d")
> y <- c(T, F, T, F)
> z <- 1.5:4.2

> print(x)
[1] "a" "b" "c" "d"

> print(y)
[1]  TRUE FALSE  TRUE FALSE

> print(z)
[1] 1.5 2.5 3.5
```

타언어의 배열과 같이 대괄호를 통해 단일 값을 가져올 수 있다. 다만 0번째 인덱스에는 벡터의 정보가 담겨있으니 값은 1부터 시작한다.

```r
> print(x[0])
character(0)

> print(x[1])
[1] "a"
```

시퀸스 함수를 통해 벡터를 만들 수 있다. `seq(시작 값, 종료 값, 순서)`

```r
> seq(1,5)
[1] 1 2 3 4 5
> seq(1,5,2)
[1] 1 3 5
```

## 3. 요인(Factor)

- 범주형 자료구조로 Set과 유사하다.
- `factor` 함수를 통해 생성할 수 있다.
- 인덱스를 통해 접근 할 수 있다(`f[1]`).
- 출력했을 때 전체 값이 한번 출력된 뒤 중복된 값이 제거된 값이 Levels: 뒤에 나타난다.

```r
# Vector
> c <- c(T, F, T, F)
> print(c)
[1]  TRUE FALSE  TRUE FALSE

# Factor
> f <- factor(c)
> print(f)
[1] TRUE  FALSE TRUE  FALSE
Levels: FALSE TRUE
```

## 4. 행렬(Matrix)

타언어의 2차원 배열과 유사한다. 보통 `matrix(행렬로_변환할_벡터, 옵션들)` 함수를 통해 행렬을 생성한다. 

옵션들(일부만)

- `ncol` : 행렬의 열의 개수(default: 벡터의 길이) : 정수타입
- `nrow` : 행렬의 행의 개수(default: 1) : 정수타입
- `byrow` : 행우선으로 데이터를 채운다(default: 열우선)   : 불리언 타입
- `dimnames` : 열과 행의 이름을 지정 `dimnames=list(열이름_벡터, 행이름_벡터)` 형식으로 작성

`ncol` 과 `nrow` 는 벡터 길이의 약수이여야 한다. 예를 들어 벡터의 길이가 9인데 `ncol` 으로 2을 입력하면 안된다. 

```r
> v <- 1:12

> matrix(v)
      [,1]
 [1,]    1
 [2,]    2
 [3,]    3
 [4,]    4
 [5,]    5
 [6,]    6
 [7,]    7
 [8,]    8
 [9,]    9
[10,]   10
[11,]   11
[12,]   12

> matrix(v, ncol=2)
     [,1] [,2]
[1,]    1    7
[2,]    2    8
[3,]    3    9
[4,]    4   10
[5,]    5   11
[6,]    6   12

> matrix(v, nrow = 3)
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12

> matrix(v, ncol=6, nrow=2)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    3    5    7    9   11
[2,]    2    4    6    8   10   12

> matrix(v, ncol=6, nrow=2, byrow=T)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    2    3    4    5    6
[2,]    7    8    9   10   11   12

> matrix(v, ncol=6, nrow=2, byrow=T, dimnames=list(c("col1", "col2"), c("row1", "row2", "row3", "row4", "row5", "row6")))
     row1 row2 row3 row4 row5 row6
col1    1    2    3    4    5    6
col2    7    8    9   10   11   12

```

행렬의 각 인덱스에 접근하는 방식은 타언어들에 비해 조금 색다르다.

```r
> A <- matrix(1:16, 4, 4)
> A
     [,1] [,2] [,3] [,4]
[1,]    1    5    9   13
[2,]    2    6   10   14
[3,]    3    7   11   15
[4,]    4    8   12   16

> A[3]     # 3열 1행
[1] 3

> A[3,]    # 3열 전체
[1]  3  7 11 15

> A[,3]    # 3행 전체
[1]  9 10 11 12

> A[2,3]   # 2열 3행
[1] 10

# 타언어들과 같이 접근할 수 없다.
> A[2][3]
[1] NA
```

-를 통해 인덱싱을 할 경우 해당 열 또는 행을 제외하고 가져온다.

```r
> A[-c(1),]          # 1열을 제외하고 가져온다.
     [,1] [,2] [,3] [,4]
[1,]    2    6   10   14
[2,]    3    7   11   15
[3,]    4    8   12   16

> A[,-c(1)]          # 1행을 제외하고 가져온다.
     [,1] [,2] [,3]
[1,]    5    9   13
[2,]    6   10   14
[3,]    7   11   15
[4,]    8   12   16

> A[-c(1), -c(1)]     # 1열과 1행을 제외하고 가져온다.
     [,1] [,2] [,3]
[1,]    6   10   14
[2,]    7   11   15
[3,]    8   12   16

# 제외할 행 또는 열을 여러개 지정할 수 있다.
> A[-c(1, 2),]        # 1열과 2열을 제외하고 가져온다.
     [,1] [,2] [,3] [,4]
[1,]    3    7   11   15
[2,]    4    8   12   16
```

## 5. 배열(Array)

타언어의 3차원 이상의 배열을 R에서는 배열이라고 부른다. `array` 함수를 통해서 만들수 있으며 첫번째 인자로 데이터(벡터)를 두번째 인자로 각 차원의 크기를 넘겨주면 된다. 

```r
> v <- 1:24

> array(v)
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24

> array(v, c(4, 6))
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,]    1    5    9   13   17   21
[2,]    2    6   10   14   18   22
[3,]    3    7   11   15   19   23
[4,]    4    8   12   16   20   24

> array(v, c(4, 3, 2))
, , 1

     [,1] [,2] [,3]
[1,]    1    5    9
[2,]    2    6   10
[3,]    3    7   11
[4,]    4    8   12

, , 2

     [,1] [,2] [,3]
[1,]   13   17   21
[2,]   14   18   22
[3,]   15   19   23
[4,]   16   20   24

> array(v, c(2, 2, 3, 2))
, , 1, 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2, 1

     [,1] [,2]
[1,]    5    7
[2,]    6    8

, , 3, 1

     [,1] [,2]
[1,]    9   11
[2,]   10   12

, , 1, 2

     [,1] [,2]
[1,]   13   15
[2,]   14   16

, , 2, 2

     [,1] [,2]
[1,]   17   19
[2,]   18   20

, , 3, 2

     [,1] [,2]
[1,]   21   23
[2,]   22   24
```

## 6. 데이터프레임(DataFrame)

데이터 유형에 상관없이 2차원 테이블을 생성한다. 

만약 데이터의 길이가 동일하지 않으면 에러가 발생된다. 단, 배열일 경우 데이터의 길이가 맞지 않는다면 값을 반복하여 채워넣는다.

```r
> c <- c("A", "B", "C", "D", "E", "F")
> n <- 6:1
> f <- factor(c(T, F, T, F, T, F))
> a <- array(1:6, c(2,3))

> a
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

> data.frame(c, n, f)
  c n     f
1 A 6  TRUE
2 B 5 FALSE
3 C 4  TRUE
4 D 3 FALSE
5 E 2  TRUE
6 F 1 FALSE

> d <- data.frame(c, n, f, a)
> print(d)
  c n     f X1 X2 X3
1 A 6  TRUE  1  3  5
2 B 5 FALSE  2  4  6
3 C 4  TRUE  1  3  5
4 D 3 FALSE  2  4  6
5 E 2  TRUE  1  3  5
6 F 1 FALSE  2  4  6
```

## 7. 리스트(List)

모든 자료형을 포괄하는 리스트 컬렉션 자료형이다. 

```r
# 위의 데이터프레임에서 사용했던 c, n, f, a, d 사용
> l <- list(c, n, f, a, d)

> print(l)
[[1]]
[1] "A" "B" "C" "D" "E" "F"

[[2]]
[1] 6 5 4 3 2 1

[[3]]
[1] TRUE  FALSE TRUE  FALSE TRUE  FALSE
Levels: FALSE TRUE

[[4]]
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

[[5]]
  c n     f X1 X2 X3
1 A 6  TRUE  1  3  5
2 B 5 FALSE  2  4  6
3 C 4  TRUE  1  3  5
4 D 3 FALSE  2  4  6
5 E 2  TRUE  1  3  5
6 F 1 FALSE  2  4  6
```