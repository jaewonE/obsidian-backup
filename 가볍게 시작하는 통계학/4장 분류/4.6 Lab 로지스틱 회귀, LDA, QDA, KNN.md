## 객체 구성

ISLR 라이브러리에 포함된 Smarket 자료를 이용할 것이다. 이 자료는 2001년에서 2005년까지 1250일에 걸친 S&R 500주가지수의 수익률로 구성되며 각 날짜에 그날 이전 5일의 각 거래일 Lag1에서 Lag5에 대한 수익률이 기록되어 있다.
* Year: 측정 연도
* Lag1, Lag2, ..., Lag5 : 각 날짜에 그날 이전 5일의 각 거래일 Lag1에서 Lag5에 대한 수익률
* Volume: 전날에 거래된 주식 수를 10억 단위로 표시
* Today: 당일의 수익률
* Direction: 당일 주가 지수(질적변수로 Up과 Down으로 구성) 

## 기본 설정
ISLR 라이브러리에 포함된 Smarket 자료를 사용할 것이기에 아래 코드를 추가하여 데이터를 불러올 것이다.
`View 명령어`를 통해 데이터를 표 형식으로 볼 수 있다.
``` R
library(ISLR)
attach(Smarket)
View(Smarket)
```

출력:
![[Smarket_view.png]]


## 로지스틱 회귀
>Lag1, ..., Lag5와 Volume을 이용하여 Direction을 예측하는 로지스틱 회귀모델을 생성한다.

로지스틱 회귀 모델은 일반화선형모델에 적합하는 함수인`gim()` 함수에 `family=binomial` 옵션을 넣어주어 생성할 수 있다. 이에 모델을 생성하고 서머리를 출력하자.
``` R
glm.fit = glm(Direction~Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + Volume, data=Smarket, family=binomial)
summary(glm.fit)
```

출력: 
``` R
Call:
glm(formula = Direction ~ Lag1 + Lag2 + Lag3 + Lag4 + Lag5 + 
    Volume, family = binomial, data = Smarket)

Deviance Residuals: 
   Min      1Q  Median      3Q     Max  
-1.446  -1.203   1.065   1.145   1.326  

Coefficients:
             Estimate Std. Error z value Pr(>|z|)
(Intercept) -0.126000   0.240736  -0.523    0.601
Lag1        -0.073074   0.050167  -1.457    0.145
Lag2        -0.042301   0.050086  -0.845    0.398
Lag3         0.011085   0.049939   0.222    0.824
Lag4         0.009359   0.049974   0.187    0.851
Lag5         0.010313   0.049511   0.208    0.835
Volume       0.135441   0.158360   0.855    0.392

(Dispersion parameter for binomial family taken to be 1)

    Null deviance: 1731.2  on 1249  degrees of freedom
Residual deviance: 1727.6  on 1243  degrees of freedom
AIC: 1741.6

Number of Fisher Scoring iterations: 3
```
>$Pr(>|z|)$는 정규분포의 절댓값이 z값의 범위를 벗어날 확률이다. 예를 들어 Lag1의 양측검정의 경우 -1.457 보다 작거나 1.457 보다 클 확률이 14.5%라는 것이다. 

<br>
predict() 함수를 사용하면 설명변수 값에 대해 주가지수가 상승할 확률을 예측할 수 있다. 이때 `type="response"` 옵션을 넣어주면 $P(Y=1|X)$ 형태의 확률(X가 $Y=1$(상승) 범위에 속해있을 확률)로 출력한다.

> 주가지수가 상승할 확률인 이유는 Direction에서 상승(Up)이 1로, 하락(Down)이 0으로 인코딩 되었기 때문이다. `contrasts(Direction)` 을 통해 확인할 수 있다. 

``` R
glm.probs = predict(glm.fit, type="response")
print(glm.probs)
```

출력:
![[glm-probs-logi.png]]

출력해보면 1250개의 값에 대한 상승할 확률이 나옴을 알 수 있다.(`dim(Smarket`)) 명령어를 통해서 알 수 있듯 본 데이터는 9개의 열과 1250개의 행(1250개의 데이터)를 가지고 있다.)
<br>
이제 예측한 값과 실제값(Direction)을 혼돈행렬을 통해 비교해보자.
``` R
# "Down" 이라는 원소를 1250개 가지는 벡터를 생성
glm.pred=rep("Down", 1250)

# 만약 glm.probs의 상승확률이 0.5보다 크면 glm.pred 벡터의 "Down" 원소를 "Up"으로 변경한다.
# glm.pred는 "Down"과 "Up"으로만 이루어진 예측값 벡터인 것이다.
glm.pred[glm.probs > .5] = "Up"

# 예측값(glm.pred) 벡터와 실제 결과(Direction)를 혼돈행렬을 통해 비교한다.
table(glm.pred, Direction)
```

출력:
``` R
        Direction
glm.pred Down  Up
    Down  145 141
    Up    457 507
```

이를 통해 민감도는 (507 + 145) / 1250 = 52.16% 이고 특이도는 (457 + 141) / 1250 = 47.84% 임을 확인 할 수 있다. 

>민감도는 각 원소가 일치할 확률의 평균과 같음으로 `mean(glm.pred == Direction)` 함수를 통해 구할 수 있다. 동일한 이유로 

>민감도: 실제로 참이면서 참으로 예측한 비율
>특이도: 실제로 거짓이면서 거짓으로 예측한 비율